## Bit encoding ##

So my first post is going to be about something I dabbled with in my master's thesis, bit encoding. Before I talk about the specific encoding I used, let me discuss some of the uses of encoding, and of course a small section on what encoding is.

#### So what is encoding? ####
According to [Wikipedia](https://en.wikipedia.org/wiki/Encoding), encoding (or code) is a system of rules to convert information. One encoding system that almost everyone have heard of is  [morse code](http://morsecode.scphillips.com/morse.html). Morse code is a system of rules that encodes and decodes the alphabet into sound or light signals. Encoding here means, for examlpe, going from the letter A to morse ( short long ), and decoding is the reverse, translating from morse (short long) to the lettar A. Basically you are translating data from one form into another.   

#### Why is it useful? ####
In order to answer this question let's take a look at an illustrative example. Concider the following, how many bits do a 64 bit unsigned integer use to represent the value 2?
```c++
uint64_t example = 2;
```
The example variable will be stored in memory as:
```
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000010
```
That is a lot of memory containing no information. 62 bits of it.

#### Designing the algorithm #####
Following the previous example one observation that can be made here is that most 64 bit values will likely not use all 64 bits. And if we are trying to reduce the amount bits used, let's just take the bits that matter, giving the following encoded bits:
```
10
```
There is at least one major problem with this approach. When decoding ```10``` we will not know if have ```1``` followed by ```0``` or it is ```2```. If we had even more values it would be very hard to know where one value ended and another one starts. So in order to enable decoding we need a delimitor. Let one bit in every byte be a flag to indicate if the current value is longer0(```0```) or not(```1```). Our previous example will then be encoded as 
```
10000010
```
and saving us the need to store/transmit 56(!) bits of worthless information.

Let's have a more interesting example. What if we were to encode the value ```300```, which would be stored in memory as: 
```
00000000 00000000 00000000 00000000 00000000 00000000 00000001 00101100
```
We start by looking at the lower 7 bits (remember one bit for information, so only 7 bits of real value), and add a 0 to indicate that we have more information comming.
```
00101100
```
In order to progress we need to remove this information from ```300``` and we do this by a [logical shift](https://en.wikipedia.org/wiki/Logical_shift) to the right with 7 bits,
```c++
300 >> 7 = 2
```
And we know from before that ```2``` is encoded to
```
10000010
```
So the value ```300``` is encoded to
```
00101100 10000010
```
Did you notice that the bytes are in reverse order?

Depending on the scheme used for encoding the result will vary, the scheme I will introduce will encode the result to just 8 bits, instead of 64. So let's take a look at the algorithm.

#### The encoding #####

```c++
uint8_t* encode(uint64_t value) {
  uint8_t* out[10];
  int i = 0;
  do {
    out[i++] = (uint8_t)(value & 0x7F);
    value >>= 7;
  } while(value);
  out[i - 1] |= 0x80;
  return out;
}
```
We will talk about what all the different pieces does in a bit, but first a high level overview.